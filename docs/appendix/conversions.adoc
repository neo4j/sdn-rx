[[conversions]]
= Conversions

We support a broad range of conversions out of the box.
Find the list of supported cypher types in the official drivers manual: https://neo4j.com/docs/driver-manual/current/cypher-values/[Working with Cypher values].

Primitive types of wrapper types are equally supported.

[cols="3,3,1", options="header"]
|===
|Domain type|Cypher type|Maps directly to native type

|`java.lang.Boolean`
|Boolean
|✔

|`boolean[]`
|List of Boolean
|✔

|`java.lang.Long`
|Integer
|✔

|`long[]`
|List of Integer
|✔

|`java.lang.Double`
|Float
|✔

|`java.lang.String`
|String
|✔


|`java.lang.String[]`
|List of String
|✔

|`byte[]`
|ByteArray
|✔

|`java.lang.Byte`
|ByteArray with length 1
|

|`java.lang.Character`
|String with length 1
|

|`char[]`
|List of String with length 1
|

|`java.util.Date`
|String formatted as ISO 8601 Date (`yyyy-MM-dd'T'HH:mm:ss.SSSZ`).
 Notice the `Z`: SDN/RX will store all `java.util.Date` instances in `UTC`.
 If you require the time zone, use a type that supports it (i.e. `ZoneDateTime`) or store the zone as a separate property.
|

|`double[]`
|List of Float
|✔

|`java.lang.Float`
|String
|

|`float[]`
|List of String
|

|`java.lang.Integer`
|Integer
|

|`int[]`
|List of Integer
|

|`java.util.Locale`
|String formatted as BCP 47 language tag
|

|`java.lang.Short`
|Integer
|

|`short[]`
|List of Integer
|

|`java.math.BigDecimal`
|String
|

|`java.math.BigInteger`
|String
|

|`java.time.LocalDate`
|Date
|✔

|`java.time.OffsetTime`
|Time
|✔

|`java.time.LocalTime`
|LocalTime
|✔

|`java.time.ZonedDateTime`
|DateTime
|✔

|`java.time.LocalDateTime`
|LocalDateTime
|✔

|`java.time.Period`
|Duration
|

|`java.time.Duration`
|Duration
|

|`org.neo4j.driver.types.IsoDuration`
|Duration
|✔

|`org.neo4j.driver.types.Point`
|Point
|✔

|`org.neo4j.springframework.data.types.GeographicPoint2d`
|Point with CRS 4326
|

|`org.neo4j.springframework.data.types.GeographicPoint3d`
|Point with CRS 4979
|

|`org.neo4j.springframework.data.types.CartesianPoint2d`
|Point with CRS 7203
|

|`org.neo4j.springframework.data.types.CartesianPoint3d`
|Point with CRS 9157
|

|`org.springframework.data.geo.Point`
|Point with CRS 4326 and x/y corresponding to lat/long
|

|Instances of `Enum`
|String (The name value of the enum)
|

|Instances of `Enum[]`
|List of String (The name value of the enum)
|

|===

== Custom conversions

If you prefer to work with your own types in the entities or as parameters for `@Query` annotated methods,
you can define and provide a custom converter implementation.
First you have to implement a `GenericConverter` and register the types your converter should handle.
For entity property type converters you need to take care of converting your type to *and* from a Neo4j Java Driver `Value`.
If your converter is supposed to work only with custom query methods in the repositories, it is sufficient
to provide the one-way conversion to the `Value` type.

.Example of a custom converter implementation
[source,java,indent=0]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/conversion/MyCustomTypeConverter.java[tag=custom-converter.implementation]
----

To make SDN/RX aware of your converter, it has to be registered in the `Neo4jConversions`.
To do this, you have to create a `@Bean` with the type `org.neo4j.springframework.data.core.convert.Neo4jConversions`.
Otherwise, the `Neo4jConversions` will get created in the background with the internal default converters only.

.Example of a custom converter implementation
[source,java,indent=0]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/conversion/MyCustomTypeConverter.java[tag=custom-converter.neo4jConversions]
----

If you need multiple converters in your application, you can add as many as you need in the `Neo4jConversions` constructor.
